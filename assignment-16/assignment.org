# -*- fill-column: 80; org-confirm-babel-evaluate: nil -*-

#+TITLE:     Assignment 16, Data-Structures
#+AUTHOR:    Oleg Sivokon
#+EMAIL:     olegsivokon@gmail.com
#+DATE:      <2016-05-25 Wed>
#+DESCRIPTION: Third assignment in the course Data-Structures
#+KEYWORDS: Data-Structures, Algorithms, Assignment
#+LANGUAGE: en
#+LaTeX_CLASS: article
#+LATEX_HEADER: \usepackage{commath}
#+LATEX_HEADER: \usepackage{pgf}
#+LATEX_HEADER: \usepackage{tikz}
#+LATEX_HEADER: \usetikzlibrary{shapes, arrows}
#+LATEX_HEADER: \usepackage{marginnote}
#+LATEX_HEADER: \usepackage{listings}
#+LATEX_HEADER: \usepackage{enumerate}
#+LATEX_HEADER: \usepackage{algpseudocode}
#+LATEX_HEADER: \usepackage{algorithm}
#+LATEX_HEADER: \usepackage{mathtools}
#+LATEX_HEADER: \setlength{\parskip}{16pt plus 2pt minus 2pt}
#+LATEX_HEADER: \renewcommand{\arraystretch}{1.6}

#+BEGIN_SRC emacs-lisp :exports none
  (setq org-latex-pdf-process
        '("latexmk -pdflatex='pdflatex -shell-escape -interaction nonstopmode' -pdf -f %f")
        org-latex-listings t
        org-src-fontify-natively t
        org-babel-latex-htlatex "htlatex")

  (defmacro by-backend (&rest body)
    `(progn
       (cl-case org-export-current-backend ,@body)))

  ;; (defmacro by-backend (&rest body)
  ;;   `(cl-case (when (boundp 'backend)
  ;;               (org-export-backend-name backend))
  ;;      ,@body))
#+END_SRC

#+RESULTS:
: by-backend

#+BEGIN_LATEX
\definecolor{codebg}{rgb}{0.96,0.99,0.8}
\definecolor{codestr}{rgb}{0.46,0.09,0.2}
\lstset{%
  backgroundcolor=\color{codebg},
  basicstyle=\ttfamily\scriptsize,
  breakatwhitespace=false,
  breaklines=false,
  captionpos=b,
  framexleftmargin=10pt,
  xleftmargin=10pt,
  framerule=0pt,
  frame=tb,
  keepspaces=true,
  keywordstyle=\color{blue},
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  stringstyle=\color{codestr},
  tabsize=2
}
\lstnewenvironment{maxima}{%
  \lstset{%
    backgroundcolor=\color{codebg},
    escapeinside={(*@}{@*)},
    aboveskip=20pt,
    captionpos=b,
    label=,
    caption=,
    showstringspaces=false,
    frame=single,
    framerule=0pt,
    basicstyle=\ttfamily\scriptsize,
    columns=fixed}}{}
}
\makeatletter
\newcommand{\verbatimfont}[1]{\renewcommand{\verbatim@font}{\ttfamily#1}}
\makeatother
\verbatimfont{\small}%
\clearpage
#+END_LATEX

* Problems

** Problem 1
   1. Given a hash-table with initial capacity $m$.  What is the probability
      four elements inserted will end up in the same bucket?
   2. Given an ordered hash-table and elements $k_1$, $k_2$ and $k_3$ inserted
      in that order, what is the chance of performing three comparisons when
      inserting the third element?
   3. Given hash-table s.t. its density is $1-\frac{1}{\lg n}$. ... What is the
      running time of ... search as the function of the array implementing the
      hash-table?

*** Answer 1

*** Answer 2

*** Answer 3

** Problem 2
   Given a set of rational numbers $S$ and a rational number $z$,
   1. write an algorithm that finds two distinct summands of $z$ with running
      time $\Theta(n)$.
   2. Same is in (2), but for four summands and time $\Theta(n^2)$.

*** Answer 4

*** Answer 5

** Problem 3
   Given a directed graph with $n$ nodes there are $n + 1$ /left/ and /right/
   nil-pointers.  After performing the following on this tree: If =left[z]= =
   =nil=, then =left[z]= = =tree-predecessor(z)=, and if =right[z]= = =nil=,
   then =right[z]= = =tree-cussessor(z)=.  The tree built in this way is called
   ``frying pan'' (WTF?), and the arcs are called ``threads''.
   1. How can one distinguish between actual arcs and ``threads''?
   2. Write procedures for inserting and removing elements from this tree.
   3. What is the benefit of using ``threads''?

*** Answer 6

*** Answer 7

*** Answer 

** Problem 4
   Given list of points $P = \{(x, y) \;|\; x^2 + y^2 \leq 0, x \geq 0\}$,
   assuming uniform random distribution of points across the semi-circle, write
   an algorithm for sorting them on $\tan \theta$, where $\theta$ is the angle
   between $x$ axis and the line through origin and the given point.

*** Answer 4
    The idea is to take =atan2= of $x$ and $y$ coordinates and use this value
    to represent the point.  Then use =bucket-sort= or =counting-sort= to sort
    points as if they were floats.  Below is the necessary code to do that:

    Point structure definitions:
    #+BEGIN_SRC C
      typedef struct point {
          printable printable;
      } point;

      float atanxy(point* p) {
          pair coords = (pair)((printable*)p)->val;
          float x = *(float*)coords->first->val;
          float y = *(float*)coords->last->val;
          if (x == 0.0) return 1;
          if (y == 0.0) return 0;
          return y / sqrt(x * x + y * y + x);
      }

      char* point_to_string(point* p) {
          size_t size = ((printable*)p)->size;
          char* result = ALLOCATE(sizeof(char) * size);
          pair coords = (pair)((printable*)p)->val;

          snprintf(result, size, "{x: %.4f, y: %.4f, t: %.4f}",
                   ,*(float*)coords->first->val,
                   ,*(float*)coords->last->val,
                   atanxy(p));
          return result;
      }
    #+END_SRC

    Auxilary functions:
    #+BEGIN_SRC C
      printable* random_point_element_generator(void* elt) {
          point* result = ALLOCATE(sizeof(point));
          printable* presult = (printable*)result;
          pair coords = make_pair();
          float x, y;
                
          x = (float)rand() / (float)RAND_MAX;
          y = (float)rand() / (float)RAND_MAX;
          coords->first = (printable*)make_printable_float(x);
          coords->last = (printable*)make_printable_float(y);
          presult->val = ALLOCATE(sizeof(pair));
          presult->val = coords;
          presult->to_string = (printer)point_to_string;
          presult->size = (3 + FLT_DIG) * 3 + 16;
          return presult;
      }

      printable* printable_atanxy(printable* p) {
          point* pt = (point*)p;
          return (printable*)make_printable_float(atanxy(pt));
      }
    #+END_SRC

    #+BEGIN_LaTeX
    \pagebreak
    #+END_LaTeX

    Callbacks for sorting algorithms:
    #+BEGIN_SRC C
      int compare_points(const void* a, const void* b) {
          point* pa = *(point**)a;
          point* pb = *(point**)b;
          if (pa == pb) return 0;
          if (pa == NULL) return -1;
          if (pb == NULL) return 1;
          float fpa = atanxy(pa);
          float fpb = atanxy(pb);
          return (fpa > fpb) - (fpa < fpb);
      }

      size_t rationalize_point(printable* elt, printable* min,
                               printable* max, size_t range) {
          float n = atanxy((point*)min);
          float x = atanxy((point*)max);
          float e = atanxy((point*)elt);
          if (x == n) return 0;
          return (size_t)(range * ((e - n) / (x - n)));
      }
    #+END_SRC
    
    Finally, example usage:
    #+BEGIN_SRC C
      int main() {
          time_t t;
          srand((unsigned)time(&t));
          array test = make_random_array(
              13, 3, 97, random_point_element_generator);
          printf("Generated points array:\n%s\n",
                 to_string((printable*)test));
          bucket_sort(test, rationalize_point, compare_points);
          printf("Sorted points array:\n%s\n",
                 to_string((printable*)test));
          array tans = array_map(test, printable_atanxy);
          printf("Tangents:\n%s\n", to_string((printable*)tans));
          return 0;
      }
    #+END_SRC

    For implementation of =array_map=, =make_random_array=, =bucket_sort= and
    =to_string= please see library code.

    #+BEGIN_LaTeX
    \pagebreak
    #+END_LaTeX

    Example output:
    #+BEGIN_EXAMPLE
      Generated points array:
      [{x: 0.8257, y: 0.8677, t: 0.7606}, {x: 0.1002, y: 0.3438, t: 0.2836},
      {x: 0.9552, y: 0.9093, t: 0.8100}, {x: 0.0602, y: 0.3771, t: 0.1584},
      {x: 0.6079, y: 0.8967, t: 0.5957}, {x: 0.2550, y: 0.9156, t: 0.2716},
      {x: 0.6398, y: 0.0718, t: 1.4590}, {x: 0.7224, y: 0.6434, t: 0.8432},
      {x: 0.9814, y: 0.6833, t: 0.9626}, {x: 0.7193, y: 0.7053, t: 0.7952},
      {x: 0.3380, y: 0.5310, t: 0.5668}, {x: 0.4476, y: 0.6312, t: 0.6168},
      {x: 0.3246, y: 0.5864, t: 0.5055}]

      Sorted points array:
      [{y: 0.3771, x: 0.0602, t: 0.1584}, {y: 0.9156, x: 0.255, t: 0.2716},
      {y: 0.3438, x: 0.1002, t: 0.2836}, {y: 0.5864, x: 0.3246, t: 0.5055},
      {y: 0.531, x: 0.338, t: 0.5668}, {y: 0.8967, x: 0.6079, t: 0.5957},
      {y: 0.6312, x: 0.4476, t: 0.6168}, {y: 0.8677, x: 0.8257, t: 0.7606},
      {y: 0.7053, x: 0.7193, t: 0.7952}, {y: 0.9093, x: 0.9552, t: 0.81},
      {y: 0.6434, x: 0.7224, t: 0.8432}, {y: 0.6833, x: 0.9814, t: 0.9626},
      {y: 0.0718, x: 0.6398, t: 1.459}]
    #+END_EXAMPLE
