<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Assignment 1.1: array.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Assignment 1.1
   </div>
   <div id="projectbrief">My homework for the class in data-structures</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">array.h File Reference<div class="ingroups"><a class="el" href="group__assignment11.html">Support code for data-structures course</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>This file defines basic functions for working with printable arrays.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &quot;<a class="el" href="printable_8h_source.html">printable.h</a>&quot;</code><br />
</div>
<p><a href="array_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarray.html">array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct is the backbone for all printable arrays.  <a href="structarray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiterator__impl.html">iterator_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The iterator information storage cell.  <a href="structiterator__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aec14133636951af4cfefa8eba04b1a8b"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structprintable.html">printable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8h.html#aec14133636951af4cfefa8eba04b1a8b">element_generator</a>(void *elt)</td></tr>
<tr class="memdesc:aec14133636951af4cfefa8eba04b1a8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The functions of this kind are used when generating all sorts of arrays (typically an array will implement a generator corresponding to its type).  <a href="#aec14133636951af4cfefa8eba04b1a8b">More...</a><br /></td></tr>
<tr class="separator:aec14133636951af4cfefa8eba04b1a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a6631e162730e046df6a09afc4e6f96"><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8h.html#a1a6631e162730e046df6a09afc4e6f96">comparison_fn_t</a>(const void *a, const void *b)</td></tr>
<tr class="memdesc:a1a6631e162730e046df6a09afc4e6f96"><td class="mdescLeft">&#160;</td><td class="mdescRight">The definition is copied from GCC extension, this is the comparator function suitable for <code>qsort</code> calls.  <a href="#a1a6631e162730e046df6a09afc4e6f96">More...</a><br /></td></tr>
<tr class="separator:a1a6631e162730e046df6a09afc4e6f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4532500868b8bb4cbbd053de03624c29"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structiterator__impl.html">iterator_impl</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8h.html#a4532500868b8bb4cbbd053de03624c29">iterator_impl</a></td></tr>
<tr class="memdesc:a4532500868b8bb4cbbd053de03624c29"><td class="mdescLeft">&#160;</td><td class="mdescRight">The iterator information storage cell.  <a href="#a4532500868b8bb4cbbd053de03624c29">More...</a><br /></td></tr>
<tr class="separator:a4532500868b8bb4cbbd053de03624c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adff7b45af8d8e548af91b5b58d0540c7"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8h.html#adff7b45af8d8e548af91b5b58d0540c7">iterator_func</a>) (<a class="el" href="structiterator__impl.html">iterator_impl</a> *it)</td></tr>
<tr class="memdesc:adff7b45af8d8e548af91b5b58d0540c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function to advance the iterator one position.  <a href="#adff7b45af8d8e548af91b5b58d0540c7">More...</a><br /></td></tr>
<tr class="separator:adff7b45af8d8e548af91b5b58d0540c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ab96854060e950fff987e7e8bbbfead06"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8h.html#ab96854060e950fff987e7e8bbbfead06">search_direction</a> { <a class="el" href="array_8h.html#ab96854060e950fff987e7e8bbbfead06ac921ff2cfc571c1d19b0485d7f6926ee">BACK</a>, 
<a class="el" href="array_8h.html#ab96854060e950fff987e7e8bbbfead06aa26736999186daf8146f809e863712a1">FORWARD</a>
 }<tr class="memdesc:ab96854060e950fff987e7e8bbbfead06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines search direction.  <a href="array_8h.html#ab96854060e950fff987e7e8bbbfead06">More...</a><br /></td></tr>
<tr class="separator:ab96854060e950fff987e7e8bbbfead06"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a60d65c817587296555101f8b50591151"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structarray.html">array</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8h.html#a60d65c817587296555101f8b50591151">sorted</a> (<a class="el" href="structarray.html">array</a> *unsorted, <a class="el" href="array_8h.html#a1a6631e162730e046df6a09afc4e6f96">comparison_fn_t</a> cmp)</td></tr>
<tr class="memdesc:a60d65c817587296555101f8b50591151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the <code>array</code> in-place using <code>cmp</code> function and returns it.  <a href="#a60d65c817587296555101f8b50591151">More...</a><br /></td></tr>
<tr class="separator:a60d65c817587296555101f8b50591151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ec40a632dae64dc79f10a402c1300fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structarray.html">array</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8h.html#a1ec40a632dae64dc79f10a402c1300fb">shuffled</a> (<a class="el" href="structarray.html">array</a> *<a class="el" href="array_8h.html#a60d65c817587296555101f8b50591151">sorted</a>)</td></tr>
<tr class="memdesc:a1ec40a632dae64dc79f10a402c1300fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shuffles the <code>array</code> in-place and returns it.  <a href="#a1ec40a632dae64dc79f10a402c1300fb">More...</a><br /></td></tr>
<tr class="separator:a1ec40a632dae64dc79f10a402c1300fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5c161f80dd5d7765b13fc73a3a85f2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structarray.html">array</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8h.html#ab5c161f80dd5d7765b13fc73a3a85f2f">make_array</a> (const size_t size, <a class="el" href="structprintable.html">printable</a> **data)</td></tr>
<tr class="memdesc:ab5c161f80dd5d7765b13fc73a3a85f2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates new <code>array</code> using <code>data</code> elements as input and returns it.  <a href="#ab5c161f80dd5d7765b13fc73a3a85f2f">More...</a><br /></td></tr>
<tr class="separator:ab5c161f80dd5d7765b13fc73a3a85f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72b4095ac333bcd08004fdaa9fa14e08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8h.html#a72b4095ac333bcd08004fdaa9fa14e08">free_array</a> (<a class="el" href="structarray.html">array</a> *freed)</td></tr>
<tr class="memdesc:a72b4095ac333bcd08004fdaa9fa14e08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the array (you must first free the elements if you want them being freed too.  <a href="#a72b4095ac333bcd08004fdaa9fa14e08">More...</a><br /></td></tr>
<tr class="separator:a72b4095ac333bcd08004fdaa9fa14e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3340550f4a0f549ef9ba8ce4b776294b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structarray.html">array</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8h.html#a3340550f4a0f549ef9ba8ce4b776294b">slice</a> (const <a class="el" href="structarray.html">array</a> *input, const size_t from, const size_t to)</td></tr>
<tr class="memdesc:a3340550f4a0f549ef9ba8ce4b776294b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an array that shares data with <code>input</code>, but starts from <code>from</code> and up to <code>to</code>.  <a href="#a3340550f4a0f549ef9ba8ce4b776294b">More...</a><br /></td></tr>
<tr class="separator:a3340550f4a0f549ef9ba8ce4b776294b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00e511e3f42b5aed3444a5df6e425c36"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8h.html#a00e511e3f42b5aed3444a5df6e425c36">binsearch</a> (const <a class="el" href="structarray.html">array</a> *input, const <a class="el" href="structprintable.html">printable</a> *elt, <a class="el" href="array_8h.html#a1a6631e162730e046df6a09afc4e6f96">comparison_fn_t</a> cmp)</td></tr>
<tr class="memdesc:a00e511e3f42b5aed3444a5df6e425c36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs binary search on <code>input</code> for <code>elt</code>. The comparison is carried out using <code>cmp</code> callback.  <a href="#a00e511e3f42b5aed3444a5df6e425c36">More...</a><br /></td></tr>
<tr class="separator:a00e511e3f42b5aed3444a5df6e425c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be4fdf9f7c10b44986b559db65b05b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structarray.html">array</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8h.html#a8be4fdf9f7c10b44986b559db65b05b5">make_dense_sorted_array</a> (const size_t size, const size_t from, <a class="el" href="array_8h.html#aec14133636951af4cfefa8eba04b1a8b">element_generator</a> generator)</td></tr>
<tr class="memdesc:a8be4fdf9f7c10b44986b559db65b05b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate dense sorted <code>array</code> with element values starting from <code>from</code>.  <a href="#a8be4fdf9f7c10b44986b559db65b05b5">More...</a><br /></td></tr>
<tr class="separator:a8be4fdf9f7c10b44986b559db65b05b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0000fe5d9ed6e57bda69eea34a07c205"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structarray.html">array</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8h.html#a0000fe5d9ed6e57bda69eea34a07c205">make_sparse_sorted_array</a> (const size_t size, const size_t from, const size_t deviation, <a class="el" href="array_8h.html#aec14133636951af4cfefa8eba04b1a8b">element_generator</a> generator)</td></tr>
<tr class="memdesc:a0000fe5d9ed6e57bda69eea34a07c205"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate sparse sorted array with element values starting from <code>from</code> and increasing by at most <code>deviation</code>, where the increase is decided using uniform random distribution.  <a href="#a0000fe5d9ed6e57bda69eea34a07c205">More...</a><br /></td></tr>
<tr class="separator:a0000fe5d9ed6e57bda69eea34a07c205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f610f167ab4a8994de4e99e1179bdf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structarray.html">array</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8h.html#a82f610f167ab4a8994de4e99e1179bdf">make_random_unique_array</a> (const size_t size, const size_t from, <a class="el" href="array_8h.html#aec14133636951af4cfefa8eba04b1a8b">element_generator</a> generator)</td></tr>
<tr class="memdesc:a82f610f167ab4a8994de4e99e1179bdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate an array where all elements are between <code>from</code> and <code>from+size</code> of size size, however elements aren't ordered.  <a href="#a82f610f167ab4a8994de4e99e1179bdf">More...</a><br /></td></tr>
<tr class="separator:a82f610f167ab4a8994de4e99e1179bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace44d78c0eaeaaa9289664b36dc6e3ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structarray.html">array</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8h.html#ace44d78c0eaeaaa9289664b36dc6e3ad">make_random_array</a> (const size_t size, const size_t low, const size_t high, <a class="el" href="array_8h.html#aec14133636951af4cfefa8eba04b1a8b">element_generator</a> generator)</td></tr>
<tr class="memdesc:ace44d78c0eaeaaa9289664b36dc6e3ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate an array where all elements are between <code>low</code> and <code>high</code> of size size. Elements may be repeated and appear in no particular order.  <a href="#ace44d78c0eaeaaa9289664b36dc6e3ad">More...</a><br /></td></tr>
<tr class="separator:ace44d78c0eaeaaa9289664b36dc6e3ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b63a54b6505ff1a366d7561d16e504b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structarray.html">array</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8h.html#a4b63a54b6505ff1a366d7561d16e504b">make_random_sorted_array</a> (const size_t size, const size_t low, const size_t high, <a class="el" href="array_8h.html#a1a6631e162730e046df6a09afc4e6f96">comparison_fn_t</a> cmp, <a class="el" href="array_8h.html#aec14133636951af4cfefa8eba04b1a8b">element_generator</a> generator)</td></tr>
<tr class="memdesc:a4b63a54b6505ff1a366d7561d16e504b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <code>make_random_array</code>, except the elements are already sorted.  <a href="#a4b63a54b6505ff1a366d7561d16e504b">More...</a><br /></td></tr>
<tr class="separator:a4b63a54b6505ff1a366d7561d16e504b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bc70c805867c3ae5fc882a1d16897c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structarray.html">array</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8h.html#a7bc70c805867c3ae5fc882a1d16897c2">make_array_from_pointer</a> (const int *data, const size_t size, <a class="el" href="array_8h.html#aec14133636951af4cfefa8eba04b1a8b">element_generator</a> generator)</td></tr>
<tr class="memdesc:a7bc70c805867c3ae5fc882a1d16897c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate an array from a simile C array of ints.  <a href="#a7bc70c805867c3ae5fc882a1d16897c2">More...</a><br /></td></tr>
<tr class="separator:a7bc70c805867c3ae5fc882a1d16897c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae556bda4eb17380f543fc1b2501babdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structarray.html">array</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8h.html#ae556bda4eb17380f543fc1b2501babdb">make_increasing_decreasing_array</a> (const size_t half_size, <a class="el" href="array_8h.html#aec14133636951af4cfefa8eba04b1a8b">element_generator</a> generator)</td></tr>
<tr class="memdesc:ae556bda4eb17380f543fc1b2501babdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate an array where elements in odd places decrease by one while the elements in even places increase by one until they are equal.  <a href="#ae556bda4eb17380f543fc1b2501babdb">More...</a><br /></td></tr>
<tr class="separator:ae556bda4eb17380f543fc1b2501babdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ef3c3f836225974ba037a65d5e148f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structarray.html">array</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8h.html#a53ef3c3f836225974ba037a65d5e148f">make_vedge_array</a> (const size_t half_size, <a class="el" href="array_8h.html#aec14133636951af4cfefa8eba04b1a8b">element_generator</a> generator)</td></tr>
<tr class="memdesc:a53ef3c3f836225974ba037a65d5e148f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate an array where elements in in its first half decrease by one starting with half the size of the array, while the elements in its second half increase by one as well, but starting from the element of the size of the array.  <a href="#a53ef3c3f836225974ba037a65d5e148f">More...</a><br /></td></tr>
<tr class="separator:a53ef3c3f836225974ba037a65d5e148f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d6f70dbb095b35b9b289cb8d131d79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structarray.html">array</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8h.html#a07d6f70dbb095b35b9b289cb8d131d79">insertion_sort</a> (<a class="el" href="structarray.html">array</a> *unsorted, <a class="el" href="array_8h.html#a1a6631e162730e046df6a09afc4e6f96">comparison_fn_t</a> cmp)</td></tr>
<tr class="memdesc:a07d6f70dbb095b35b9b289cb8d131d79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the array using given comparison function.  <a href="#a07d6f70dbb095b35b9b289cb8d131d79">More...</a><br /></td></tr>
<tr class="separator:a07d6f70dbb095b35b9b289cb8d131d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ba95324821888148365ffc368f9ce6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8h.html#af2ba95324821888148365ffc368f9ce6">start_swap_count</a> ()</td></tr>
<tr class="memdesc:af2ba95324821888148365ffc368f9ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restets the swap operation counter.  <a href="#af2ba95324821888148365ffc368f9ce6">More...</a><br /></td></tr>
<tr class="separator:af2ba95324821888148365ffc368f9ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7e3ba025361d1bc714c94a0e92ec20d"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8h.html#ab7e3ba025361d1bc714c94a0e92ec20d">get_swap_count</a> ()</td></tr>
<tr class="memdesc:ab7e3ba025361d1bc714c94a0e92ec20d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of <code>swap</code> operations performed since swap conter was last reset.  <a href="#ab7e3ba025361d1bc714c94a0e92ec20d">More...</a><br /></td></tr>
<tr class="separator:ab7e3ba025361d1bc714c94a0e92ec20d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2d8124f3b1adb8c181629681ab10950"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8h.html#ad2d8124f3b1adb8c181629681ab10950">to_string_array</a> (const <a class="el" href="structarray.html">array</a> *p)</td></tr>
<tr class="memdesc:ad2d8124f3b1adb8c181629681ab10950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a string representing the given <code>array</code>.  <a href="#ad2d8124f3b1adb8c181629681ab10950">More...</a><br /></td></tr>
<tr class="separator:ad2d8124f3b1adb8c181629681ab10950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e444ddb2e14381a45aab7d6c342ec6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8h.html#a91e444ddb2e14381a45aab7d6c342ec6">next</a> (<a class="el" href="structiterator__impl.html">iterator_impl</a> *impl)</td></tr>
<tr class="memdesc:a91e444ddb2e14381a45aab7d6c342ec6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The interface to iterating the array.  <a href="#a91e444ddb2e14381a45aab7d6c342ec6">More...</a><br /></td></tr>
<tr class="separator:a91e444ddb2e14381a45aab7d6c342ec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79264f6244f67d26a763d5851838864e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structiterator__impl.html">iterator_impl</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8h.html#a79264f6244f67d26a763d5851838864e">iterator</a> (<a class="el" href="structarray.html">array</a> *iterated)</td></tr>
<tr class="memdesc:a79264f6244f67d26a763d5851838864e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The concrete iterator implementation.  <a href="#a79264f6244f67d26a763d5851838864e">More...</a><br /></td></tr>
<tr class="separator:a79264f6244f67d26a763d5851838864e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file defines basic functions for working with printable arrays. </p>
<p>This file contains declarations for basic data-structures needed to work with differently-typed arrays and being able to pretty-print them.</p>
<dl class="section author"><dt>Author</dt><dd>Oleg Sivokon</dd></dl>
<dl class="section date"><dt>Date</dt><dd></dd></dl>
<dl class="section rcs"><dt>Date</dt><dd>2016/03/05 </dd></dl>
<p>Contact: <a href="#" onclick="location.href='mai'+'lto:'+'ole'+'gs'+'ivo'+'ko'+'n@g'+'ma'+'il.'+'co'+'m'; return false;">olegs<span style="display: none;">.nosp@m.</span>ivok<span style="display: none;">.nosp@m.</span>on@gm<span style="display: none;">.nosp@m.</span>ail.<span style="display: none;">.nosp@m.</span>com</a> </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a1a6631e162730e046df6a09afc4e6f96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">comparison_fn_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The definition is copied from GCC extension, this is the comparator function suitable for <code>qsort</code> calls. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First value to compare. </td></tr>
    <tr><td class="paramname">b</td><td>Second value to compare. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aec14133636951af4cfefa8eba04b1a8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">element_generator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The functions of this kind are used when generating all sorts of arrays (typically an array will implement a generator corresponding to its type). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elt</td><td>The pointer to the value to wrap in <code>printable</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boxed value of the element. </dd></dl>

</div>
</div>
<a class="anchor" id="adff7b45af8d8e548af91b5b58d0540c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* iterator_func) (<a class="el" href="structiterator__impl.html">iterator_impl</a> *it)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function to advance the iterator one position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>The iterator being acted on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4532500868b8bb4cbbd053de03624c29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structiterator__impl.html">iterator_impl</a> <a class="el" href="structiterator__impl.html">iterator_impl</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The iterator information storage cell. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ab96854060e950fff987e7e8bbbfead06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="array_8h.html#ab96854060e950fff987e7e8bbbfead06">search_direction</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines search direction. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ab96854060e950fff987e7e8bbbfead06ac921ff2cfc571c1d19b0485d7f6926ee"></a>BACK&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab96854060e950fff987e7e8bbbfead06aa26736999186daf8146f809e863712a1"></a>FORWARD&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a00e511e3f42b5aed3444a5df6e425c36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t binsearch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structarray.html">array</a> *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structprintable.html">printable</a> *&#160;</td>
          <td class="paramname"><em>elt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="array_8h.html#a1a6631e162730e046df6a09afc4e6f96">comparison_fn_t</a>&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs binary search on <code>input</code> for <code>elt</code>. The comparison is carried out using <code>cmp</code> callback. </p>
<dl class="section return"><dt>Returns</dt><dd>The index of the searched element in the array.</dd></dl>
<p>When the element is not found in the array, the value returned is the array's length. Note that the array is assumed to be sorted, however duplicate items are OK. </p>

</div>
</div>
<a class="anchor" id="a72b4095ac333bcd08004fdaa9fa14e08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void free_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structarray.html">array</a> *&#160;</td>
          <td class="paramname"><em>freed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the array (you must first free the elements if you want them being freed too. </p>

</div>
</div>
<a class="anchor" id="ab7e3ba025361d1bc714c94a0e92ec20d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long get_swap_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of <code>swap</code> operations performed since swap conter was last reset. </p>

</div>
</div>
<a class="anchor" id="a07d6f70dbb095b35b9b289cb8d131d79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structarray.html">array</a>* insertion_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structarray.html">array</a> *&#160;</td>
          <td class="paramname"><em>unsorted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="array_8h.html#a1a6631e162730e046df6a09afc4e6f96">comparison_fn_t</a>&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts the array using given comparison function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unsorted</td><td>The array to sort (modified in place) </td></tr>
    <tr><td class="paramname">cmp</td><td>The function to compare two elements of the given array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <code>array</code> (no new allocations are made). </dd></dl>

</div>
</div>
<a class="anchor" id="a79264f6244f67d26a763d5851838864e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structiterator__impl.html">iterator_impl</a>* iterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structarray.html">array</a> *&#160;</td>
          <td class="paramname"><em>iterated</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The concrete iterator implementation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterated</td><td>The array to create an iterator for. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab5c161f80dd5d7765b13fc73a3a85f2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structarray.html">array</a>* make_array </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structprintable.html">printable</a> **&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates new <code>array</code> using <code>data</code> elements as input and returns it. </p>

</div>
</div>
<a class="anchor" id="a7bc70c805867c3ae5fc882a1d16897c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structarray.html">array</a>* make_array_from_pointer </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="array_8h.html#aec14133636951af4cfefa8eba04b1a8b">element_generator</a>&#160;</td>
          <td class="paramname"><em>generator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate an array from a simile C array of ints. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>How many elements to generate. </td></tr>
    <tr><td class="paramname">data</td><td>The original C array. </td></tr>
    <tr><td class="paramname">generator</td><td>A function to generate an element given a pointer to the generated value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <code>array</code> (the callers are responsible to deallocate it). </dd></dl>

</div>
</div>
<a class="anchor" id="a8be4fdf9f7c10b44986b559db65b05b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structarray.html">array</a>* make_dense_sorted_array </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="array_8h.html#aec14133636951af4cfefa8eba04b1a8b">element_generator</a>&#160;</td>
          <td class="paramname"><em>generator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate dense sorted <code>array</code> with element values starting from <code>from</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>How many elements to generate. </td></tr>
    <tr><td class="paramname">from</td><td>The value of the first element. </td></tr>
    <tr><td class="paramname">generator</td><td>The function to generate array elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <code>array</code> (the callers are responsible to deallocate it). </dd></dl>

</div>
</div>
<a class="anchor" id="ae556bda4eb17380f543fc1b2501babdb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structarray.html">array</a>* make_increasing_decreasing_array </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>half_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="array_8h.html#aec14133636951af4cfefa8eba04b1a8b">element_generator</a>&#160;</td>
          <td class="paramname"><em>generator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate an array where elements in odd places decrease by one while the elements in even places increase by one until they are equal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">half_size</td><td>The largest element in this array. </td></tr>
    <tr><td class="paramname">generator</td><td>A function to generate an element given a pointer to the generated value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <code>array</code> (the callers are responsible to deallocate it). </dd></dl>

</div>
</div>
<a class="anchor" id="ace44d78c0eaeaaa9289664b36dc6e3ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structarray.html">array</a>* make_random_array </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>high</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="array_8h.html#aec14133636951af4cfefa8eba04b1a8b">element_generator</a>&#160;</td>
          <td class="paramname"><em>generator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate an array where all elements are between <code>low</code> and <code>high</code> of size size. Elements may be repeated and appear in no particular order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>How many elements to generate. </td></tr>
    <tr><td class="paramname">low</td><td>The elements in array are at least this big. </td></tr>
    <tr><td class="paramname">high</td><td>The elements in array are at no larger than this. </td></tr>
    <tr><td class="paramname">generator</td><td>The function to generate array elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <code>array</code> (the callers are responsible to deallocate it). </dd></dl>

</div>
</div>
<a class="anchor" id="a4b63a54b6505ff1a366d7561d16e504b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structarray.html">array</a>* make_random_sorted_array </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>high</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="array_8h.html#a1a6631e162730e046df6a09afc4e6f96">comparison_fn_t</a>&#160;</td>
          <td class="paramname"><em>cmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="array_8h.html#aec14133636951af4cfefa8eba04b1a8b">element_generator</a>&#160;</td>
          <td class="paramname"><em>generator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <code>make_random_array</code>, except the elements are already sorted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>How many elements to generate. </td></tr>
    <tr><td class="paramname">low</td><td>The elements in array are at least this big. </td></tr>
    <tr><td class="paramname">high</td><td>The elements in array are at no larger than this. </td></tr>
    <tr><td class="paramname">cmp</td><td>A function to compare two array elements. </td></tr>
    <tr><td class="paramname">generator</td><td>The function to generate array elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <code>array</code> (the callers are responsible to deallocate it). </dd></dl>

</div>
</div>
<a class="anchor" id="a82f610f167ab4a8994de4e99e1179bdf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structarray.html">array</a>* make_random_unique_array </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="array_8h.html#aec14133636951af4cfefa8eba04b1a8b">element_generator</a>&#160;</td>
          <td class="paramname"><em>generator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate an array where all elements are between <code>from</code> and <code>from+size</code> of size size, however elements aren't ordered. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>How many elements to generate. </td></tr>
    <tr><td class="paramname">from</td><td>The value of the first element. </td></tr>
    <tr><td class="paramname">generator</td><td>A function to generate an element given a pointer to the generated value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <code>array</code> (the callers are responsible to deallocate it). </dd></dl>

</div>
</div>
<a class="anchor" id="a0000fe5d9ed6e57bda69eea34a07c205"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structarray.html">array</a>* make_sparse_sorted_array </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>deviation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="array_8h.html#aec14133636951af4cfefa8eba04b1a8b">element_generator</a>&#160;</td>
          <td class="paramname"><em>generator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate sparse sorted array with element values starting from <code>from</code> and increasing by at most <code>deviation</code>, where the increase is decided using uniform random distribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>How many elements to generate. </td></tr>
    <tr><td class="paramname">from</td><td>The value of the first element. </td></tr>
    <tr><td class="paramname">deviation</td><td>How much the elements could differ (must be positive). </td></tr>
    <tr><td class="paramname">generator</td><td>A function to generate an element given a pointer to the generated value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <code>array</code> (the callers are responsible to deallocate it). </dd></dl>

</div>
</div>
<a class="anchor" id="a53ef3c3f836225974ba037a65d5e148f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structarray.html">array</a>* make_vedge_array </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>half_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="array_8h.html#aec14133636951af4cfefa8eba04b1a8b">element_generator</a>&#160;</td>
          <td class="paramname"><em>generator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate an array where elements in in its first half decrease by one starting with half the size of the array, while the elements in its second half increase by one as well, but starting from the element of the size of the array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">half_size</td><td>The largest element in this array. </td></tr>
    <tr><td class="paramname">generator</td><td>A function to generate an element given a pointer to the generated value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <code>array</code> (the callers are responsible to deallocate it). </dd></dl>

</div>
</div>
<a class="anchor" id="a91e444ddb2e14381a45aab7d6c342ec6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structiterator__impl.html">iterator_impl</a> *&#160;</td>
          <td class="paramname"><em>impl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The interface to iterating the array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">impl</td><td>The iterator aced on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1ec40a632dae64dc79f10a402c1300fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structarray.html">array</a>* shuffled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structarray.html">array</a> *&#160;</td>
          <td class="paramname"><em>sorted</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shuffles the <code>array</code> in-place and returns it. </p>

</div>
</div>
<a class="anchor" id="a3340550f4a0f549ef9ba8ce4b776294b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structarray.html">array</a>* slice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structarray.html">array</a> *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an array that shares data with <code>input</code>, but starts from <code>from</code> and up to <code>to</code>. </p>

</div>
</div>
<a class="anchor" id="a60d65c817587296555101f8b50591151"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structarray.html">array</a>* sorted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structarray.html">array</a> *&#160;</td>
          <td class="paramname"><em>unsorted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="array_8h.html#a1a6631e162730e046df6a09afc4e6f96">comparison_fn_t</a>&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts the <code>array</code> in-place using <code>cmp</code> function and returns it. </p>

</div>
</div>
<a class="anchor" id="af2ba95324821888148365ffc368f9ce6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void start_swap_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restets the swap operation counter. </p>

</div>
</div>
<a class="anchor" id="ad2d8124f3b1adb8c181629681ab10950"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* to_string_array </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structarray.html">array</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a string representing the given <code>array</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <code>array</code> to print. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
