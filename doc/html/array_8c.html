<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Assignment 1.1: array.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Assignment 1.1
   </div>
   <div id="projectbrief">My homework for the class in data-structures</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">array.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &lt;time.h&gt;</code><br />
<code>#include &quot;<a class="el" href="array_8h_source.html">array.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="printable_8h_source.html">printable.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad2d8124f3b1adb8c181629681ab10950"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8c.html#ad2d8124f3b1adb8c181629681ab10950">to_string_array</a> (const <a class="el" href="structarray.html">array</a> *p)</td></tr>
<tr class="memdesc:ad2d8124f3b1adb8c181629681ab10950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a string representing the given <code>array</code>.  <a href="#ad2d8124f3b1adb8c181629681ab10950">More...</a><br /></td></tr>
<tr class="separator:ad2d8124f3b1adb8c181629681ab10950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5c161f80dd5d7765b13fc73a3a85f2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structarray.html">array</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8c.html#ab5c161f80dd5d7765b13fc73a3a85f2f">make_array</a> (const size_t size, <a class="el" href="structprintable.html">printable</a> **data)</td></tr>
<tr class="memdesc:ab5c161f80dd5d7765b13fc73a3a85f2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates new <code>array</code> using <code>data</code> elements as input and returns it.  <a href="#ab5c161f80dd5d7765b13fc73a3a85f2f">More...</a><br /></td></tr>
<tr class="separator:ab5c161f80dd5d7765b13fc73a3a85f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72b4095ac333bcd08004fdaa9fa14e08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8c.html#a72b4095ac333bcd08004fdaa9fa14e08">free_array</a> (<a class="el" href="structarray.html">array</a> *freed)</td></tr>
<tr class="memdesc:a72b4095ac333bcd08004fdaa9fa14e08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the array (you must first free the elements if you want them being freed too.  <a href="#a72b4095ac333bcd08004fdaa9fa14e08">More...</a><br /></td></tr>
<tr class="separator:a72b4095ac333bcd08004fdaa9fa14e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d65c817587296555101f8b50591151"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structarray.html">array</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8c.html#a60d65c817587296555101f8b50591151">sorted</a> (<a class="el" href="structarray.html">array</a> *unsorted, <a class="el" href="array_8h.html#a1a6631e162730e046df6a09afc4e6f96">comparison_fn_t</a> cmp)</td></tr>
<tr class="memdesc:a60d65c817587296555101f8b50591151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the <code>array</code> in-place using <code>cmp</code> function and returns it.  <a href="#a60d65c817587296555101f8b50591151">More...</a><br /></td></tr>
<tr class="separator:a60d65c817587296555101f8b50591151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ec40a632dae64dc79f10a402c1300fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structarray.html">array</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8c.html#a1ec40a632dae64dc79f10a402c1300fb">shuffled</a> (<a class="el" href="structarray.html">array</a> *<a class="el" href="array_8h.html#a60d65c817587296555101f8b50591151">sorted</a>)</td></tr>
<tr class="memdesc:a1ec40a632dae64dc79f10a402c1300fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shuffles the <code>array</code> in-place and returns it.  <a href="#a1ec40a632dae64dc79f10a402c1300fb">More...</a><br /></td></tr>
<tr class="separator:a1ec40a632dae64dc79f10a402c1300fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3340550f4a0f549ef9ba8ce4b776294b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structarray.html">array</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8c.html#a3340550f4a0f549ef9ba8ce4b776294b">slice</a> (const <a class="el" href="structarray.html">array</a> *input, const size_t from, const size_t to)</td></tr>
<tr class="memdesc:a3340550f4a0f549ef9ba8ce4b776294b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an array that shares data with <code>input</code>, but starts from <code>from</code> and up to <code>to</code>.  <a href="#a3340550f4a0f549ef9ba8ce4b776294b">More...</a><br /></td></tr>
<tr class="separator:a3340550f4a0f549ef9ba8ce4b776294b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23d6716654d07bac395af9cbcc015138"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8c.html#a23d6716654d07bac395af9cbcc015138">linsearch</a> (const <a class="el" href="structarray.html">array</a> *input, const void *elt, size_t from, <a class="el" href="array_8h.html#ab96854060e950fff987e7e8bbbfead06">search_direction</a> dir, <a class="el" href="array_8h.html#a1a6631e162730e046df6a09afc4e6f96">comparison_fn_t</a> cmp)</td></tr>
<tr class="separator:a23d6716654d07bac395af9cbcc015138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00e511e3f42b5aed3444a5df6e425c36"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8c.html#a00e511e3f42b5aed3444a5df6e425c36">binsearch</a> (const <a class="el" href="structarray.html">array</a> *input, const <a class="el" href="structprintable.html">printable</a> *elt, <a class="el" href="array_8h.html#a1a6631e162730e046df6a09afc4e6f96">comparison_fn_t</a> cmp)</td></tr>
<tr class="memdesc:a00e511e3f42b5aed3444a5df6e425c36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs binary search on <code>input</code> for <code>elt</code>. The comparison is carried out using <code>cmp</code> callback.  <a href="#a00e511e3f42b5aed3444a5df6e425c36">More...</a><br /></td></tr>
<tr class="separator:a00e511e3f42b5aed3444a5df6e425c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace44d78c0eaeaaa9289664b36dc6e3ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structarray.html">array</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8c.html#ace44d78c0eaeaaa9289664b36dc6e3ad">make_random_array</a> (const size_t size, const size_t low, const size_t high, <a class="el" href="array_8h.html#aec14133636951af4cfefa8eba04b1a8b">element_generator</a> generator)</td></tr>
<tr class="memdesc:ace44d78c0eaeaaa9289664b36dc6e3ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate an array where all elements are between <code>low</code> and <code>high</code> of size size. Elements may be repeated and appear in no particular order.  <a href="#ace44d78c0eaeaaa9289664b36dc6e3ad">More...</a><br /></td></tr>
<tr class="separator:ace44d78c0eaeaaa9289664b36dc6e3ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b63a54b6505ff1a366d7561d16e504b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structarray.html">array</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8c.html#a4b63a54b6505ff1a366d7561d16e504b">make_random_sorted_array</a> (const size_t size, const size_t low, const size_t high, <a class="el" href="array_8h.html#a1a6631e162730e046df6a09afc4e6f96">comparison_fn_t</a> cmp, <a class="el" href="array_8h.html#aec14133636951af4cfefa8eba04b1a8b">element_generator</a> generator)</td></tr>
<tr class="memdesc:a4b63a54b6505ff1a366d7561d16e504b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <code>make_random_array</code>, except the elements are already sorted.  <a href="#a4b63a54b6505ff1a366d7561d16e504b">More...</a><br /></td></tr>
<tr class="separator:a4b63a54b6505ff1a366d7561d16e504b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be4fdf9f7c10b44986b559db65b05b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structarray.html">array</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8c.html#a8be4fdf9f7c10b44986b559db65b05b5">make_dense_sorted_array</a> (const size_t size, const size_t from, <a class="el" href="array_8h.html#aec14133636951af4cfefa8eba04b1a8b">element_generator</a> generator)</td></tr>
<tr class="memdesc:a8be4fdf9f7c10b44986b559db65b05b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate dense sorted <code>array</code> with element values starting from <code>from</code>.  <a href="#a8be4fdf9f7c10b44986b559db65b05b5">More...</a><br /></td></tr>
<tr class="separator:a8be4fdf9f7c10b44986b559db65b05b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0000fe5d9ed6e57bda69eea34a07c205"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structarray.html">array</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8c.html#a0000fe5d9ed6e57bda69eea34a07c205">make_sparse_sorted_array</a> (const size_t size, const size_t from, const size_t deviation, <a class="el" href="array_8h.html#aec14133636951af4cfefa8eba04b1a8b">element_generator</a> generator)</td></tr>
<tr class="memdesc:a0000fe5d9ed6e57bda69eea34a07c205"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate sparse sorted array with element values starting from <code>from</code> and increasing by at most <code>deviation</code>, where the increase is decided using uniform random distribution.  <a href="#a0000fe5d9ed6e57bda69eea34a07c205">More...</a><br /></td></tr>
<tr class="separator:a0000fe5d9ed6e57bda69eea34a07c205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f610f167ab4a8994de4e99e1179bdf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structarray.html">array</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8c.html#a82f610f167ab4a8994de4e99e1179bdf">make_random_unique_array</a> (const size_t size, const size_t from, <a class="el" href="array_8h.html#aec14133636951af4cfefa8eba04b1a8b">element_generator</a> generator)</td></tr>
<tr class="memdesc:a82f610f167ab4a8994de4e99e1179bdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate an array where all elements are between <code>from</code> and <code>from+size</code> of size size, however elements aren't ordered.  <a href="#a82f610f167ab4a8994de4e99e1179bdf">More...</a><br /></td></tr>
<tr class="separator:a82f610f167ab4a8994de4e99e1179bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bc70c805867c3ae5fc882a1d16897c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structarray.html">array</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8c.html#a7bc70c805867c3ae5fc882a1d16897c2">make_array_from_pointer</a> (const int *data, const size_t size, <a class="el" href="array_8h.html#aec14133636951af4cfefa8eba04b1a8b">element_generator</a> generator)</td></tr>
<tr class="memdesc:a7bc70c805867c3ae5fc882a1d16897c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate an array from a simile C array of ints.  <a href="#a7bc70c805867c3ae5fc882a1d16897c2">More...</a><br /></td></tr>
<tr class="separator:a7bc70c805867c3ae5fc882a1d16897c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae556bda4eb17380f543fc1b2501babdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structarray.html">array</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8c.html#ae556bda4eb17380f543fc1b2501babdb">make_increasing_decreasing_array</a> (const size_t half_size, <a class="el" href="array_8h.html#aec14133636951af4cfefa8eba04b1a8b">element_generator</a> generator)</td></tr>
<tr class="memdesc:ae556bda4eb17380f543fc1b2501babdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate an array where elements in odd places decrease by one while the elements in even places increase by one until they are equal.  <a href="#ae556bda4eb17380f543fc1b2501babdb">More...</a><br /></td></tr>
<tr class="separator:ae556bda4eb17380f543fc1b2501babdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ef3c3f836225974ba037a65d5e148f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structarray.html">array</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8c.html#a53ef3c3f836225974ba037a65d5e148f">make_vedge_array</a> (const size_t half_size, <a class="el" href="array_8h.html#aec14133636951af4cfefa8eba04b1a8b">element_generator</a> generator)</td></tr>
<tr class="memdesc:a53ef3c3f836225974ba037a65d5e148f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate an array where elements in in its first half decrease by one starting with half the size of the array, while the elements in its second half increase by one as well, but starting from the element of the size of the array.  <a href="#a53ef3c3f836225974ba037a65d5e148f">More...</a><br /></td></tr>
<tr class="separator:a53ef3c3f836225974ba037a65d5e148f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ba95324821888148365ffc368f9ce6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8c.html#af2ba95324821888148365ffc368f9ce6">start_swap_count</a> ()</td></tr>
<tr class="memdesc:af2ba95324821888148365ffc368f9ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restets the swap operation counter.  <a href="#af2ba95324821888148365ffc368f9ce6">More...</a><br /></td></tr>
<tr class="separator:af2ba95324821888148365ffc368f9ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7e3ba025361d1bc714c94a0e92ec20d"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8c.html#ab7e3ba025361d1bc714c94a0e92ec20d">get_swap_count</a> ()</td></tr>
<tr class="memdesc:ab7e3ba025361d1bc714c94a0e92ec20d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of <code>swap</code> operations performed since swap conter was last reset.  <a href="#ab7e3ba025361d1bc714c94a0e92ec20d">More...</a><br /></td></tr>
<tr class="separator:ab7e3ba025361d1bc714c94a0e92ec20d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b8341fd64c0b0bb6b07f71751177e4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8c.html#a8b8341fd64c0b0bb6b07f71751177e4d">swap</a> (<a class="el" href="structarray.html">array</a> *input, size_t a, size_t b)</td></tr>
<tr class="separator:a8b8341fd64c0b0bb6b07f71751177e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fe4af678d0cb1b324ddf65dda6a5678"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8c.html#a4fe4af678d0cb1b324ddf65dda6a5678">insert</a> (<a class="el" href="structarray.html">array</a> *input, <a class="el" href="array_8h.html#a1a6631e162730e046df6a09afc4e6f96">comparison_fn_t</a> cmp, size_t pos)</td></tr>
<tr class="separator:a4fe4af678d0cb1b324ddf65dda6a5678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d6f70dbb095b35b9b289cb8d131d79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structarray.html">array</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8c.html#a07d6f70dbb095b35b9b289cb8d131d79">insertion_sort</a> (<a class="el" href="structarray.html">array</a> *unsorted, <a class="el" href="array_8h.html#a1a6631e162730e046df6a09afc4e6f96">comparison_fn_t</a> cmp)</td></tr>
<tr class="memdesc:a07d6f70dbb095b35b9b289cb8d131d79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the array using given comparison function.  <a href="#a07d6f70dbb095b35b9b289cb8d131d79">More...</a><br /></td></tr>
<tr class="separator:a07d6f70dbb095b35b9b289cb8d131d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e444ddb2e14381a45aab7d6c342ec6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8c.html#a91e444ddb2e14381a45aab7d6c342ec6">next</a> (<a class="el" href="structiterator__impl.html">iterator_impl</a> *impl)</td></tr>
<tr class="memdesc:a91e444ddb2e14381a45aab7d6c342ec6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The interface to iterating the array.  <a href="#a91e444ddb2e14381a45aab7d6c342ec6">More...</a><br /></td></tr>
<tr class="separator:a91e444ddb2e14381a45aab7d6c342ec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44ca12fe5a67ef3dc7c44ab630a025d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8c.html#a44ca12fe5a67ef3dc7c44ab630a025d3">next_it</a> (<a class="el" href="structiterator__impl.html">iterator_impl</a> *impl)</td></tr>
<tr class="separator:a44ca12fe5a67ef3dc7c44ab630a025d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79264f6244f67d26a763d5851838864e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structiterator__impl.html">iterator_impl</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array_8c.html#a79264f6244f67d26a763d5851838864e">iterator</a> (<a class="el" href="structarray.html">array</a> *iterated)</td></tr>
<tr class="memdesc:a79264f6244f67d26a763d5851838864e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The concrete iterator implementation.  <a href="#a79264f6244f67d26a763d5851838864e">More...</a><br /></td></tr>
<tr class="separator:a79264f6244f67d26a763d5851838864e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a00e511e3f42b5aed3444a5df6e425c36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t binsearch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structarray.html">array</a> *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structprintable.html">printable</a> *&#160;</td>
          <td class="paramname"><em>elt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="array_8h.html#a1a6631e162730e046df6a09afc4e6f96">comparison_fn_t</a>&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs binary search on <code>input</code> for <code>elt</code>. The comparison is carried out using <code>cmp</code> callback. </p>
<dl class="section return"><dt>Returns</dt><dd>The index of the searched element in the array.</dd></dl>
<p>When the element is not found in the array, the value returned is the array's length. Note that the array is assumed to be sorted, however duplicate items are OK. </p>

</div>
</div>
<a class="anchor" id="a72b4095ac333bcd08004fdaa9fa14e08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void free_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structarray.html">array</a> *&#160;</td>
          <td class="paramname"><em>freed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the array (you must first free the elements if you want them being freed too. </p>

</div>
</div>
<a class="anchor" id="ab7e3ba025361d1bc714c94a0e92ec20d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long get_swap_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of <code>swap</code> operations performed since swap conter was last reset. </p>

</div>
</div>
<a class="anchor" id="a4fe4af678d0cb1b324ddf65dda6a5678"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structarray.html">array</a> *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="array_8h.html#a1a6631e162730e046df6a09afc4e6f96">comparison_fn_t</a>&#160;</td>
          <td class="paramname"><em>cmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a07d6f70dbb095b35b9b289cb8d131d79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structarray.html">array</a>* insertion_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structarray.html">array</a> *&#160;</td>
          <td class="paramname"><em>unsorted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="array_8h.html#a1a6631e162730e046df6a09afc4e6f96">comparison_fn_t</a>&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts the array using given comparison function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unsorted</td><td>The array to sort (modified in place) </td></tr>
    <tr><td class="paramname">cmp</td><td>The function to compare two elements of the given array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <code>array</code> (no new allocations are made). </dd></dl>

</div>
</div>
<a class="anchor" id="a79264f6244f67d26a763d5851838864e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structiterator__impl.html">iterator_impl</a>* iterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structarray.html">array</a> *&#160;</td>
          <td class="paramname"><em>iterated</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The concrete iterator implementation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterated</td><td>The array to create an iterator for. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a23d6716654d07bac395af9cbcc015138"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t linsearch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structarray.html">array</a> *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>elt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="array_8h.html#ab96854060e950fff987e7e8bbbfead06">search_direction</a>&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="array_8h.html#a1a6631e162730e046df6a09afc4e6f96">comparison_fn_t</a>&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab5c161f80dd5d7765b13fc73a3a85f2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structarray.html">array</a>* make_array </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structprintable.html">printable</a> **&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates new <code>array</code> using <code>data</code> elements as input and returns it. </p>

</div>
</div>
<a class="anchor" id="a7bc70c805867c3ae5fc882a1d16897c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structarray.html">array</a>* make_array_from_pointer </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="array_8h.html#aec14133636951af4cfefa8eba04b1a8b">element_generator</a>&#160;</td>
          <td class="paramname"><em>generator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate an array from a simile C array of ints. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>How many elements to generate. </td></tr>
    <tr><td class="paramname">data</td><td>The original C array. </td></tr>
    <tr><td class="paramname">generator</td><td>A function to generate an element given a pointer to the generated value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <code>array</code> (the callers are responsible to deallocate it). </dd></dl>

</div>
</div>
<a class="anchor" id="a8be4fdf9f7c10b44986b559db65b05b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structarray.html">array</a>* make_dense_sorted_array </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="array_8h.html#aec14133636951af4cfefa8eba04b1a8b">element_generator</a>&#160;</td>
          <td class="paramname"><em>generator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate dense sorted <code>array</code> with element values starting from <code>from</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>How many elements to generate. </td></tr>
    <tr><td class="paramname">from</td><td>The value of the first element. </td></tr>
    <tr><td class="paramname">generator</td><td>The function to generate array elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <code>array</code> (the callers are responsible to deallocate it). </dd></dl>

</div>
</div>
<a class="anchor" id="ae556bda4eb17380f543fc1b2501babdb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structarray.html">array</a>* make_increasing_decreasing_array </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>half_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="array_8h.html#aec14133636951af4cfefa8eba04b1a8b">element_generator</a>&#160;</td>
          <td class="paramname"><em>generator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate an array where elements in odd places decrease by one while the elements in even places increase by one until they are equal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">half_size</td><td>The largest element in this array. </td></tr>
    <tr><td class="paramname">generator</td><td>A function to generate an element given a pointer to the generated value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <code>array</code> (the callers are responsible to deallocate it). </dd></dl>

</div>
</div>
<a class="anchor" id="ace44d78c0eaeaaa9289664b36dc6e3ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structarray.html">array</a>* make_random_array </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>high</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="array_8h.html#aec14133636951af4cfefa8eba04b1a8b">element_generator</a>&#160;</td>
          <td class="paramname"><em>generator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate an array where all elements are between <code>low</code> and <code>high</code> of size size. Elements may be repeated and appear in no particular order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>How many elements to generate. </td></tr>
    <tr><td class="paramname">low</td><td>The elements in array are at least this big. </td></tr>
    <tr><td class="paramname">high</td><td>The elements in array are at no larger than this. </td></tr>
    <tr><td class="paramname">generator</td><td>The function to generate array elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <code>array</code> (the callers are responsible to deallocate it). </dd></dl>

</div>
</div>
<a class="anchor" id="a4b63a54b6505ff1a366d7561d16e504b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structarray.html">array</a>* make_random_sorted_array </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>high</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="array_8h.html#a1a6631e162730e046df6a09afc4e6f96">comparison_fn_t</a>&#160;</td>
          <td class="paramname"><em>cmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="array_8h.html#aec14133636951af4cfefa8eba04b1a8b">element_generator</a>&#160;</td>
          <td class="paramname"><em>generator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <code>make_random_array</code>, except the elements are already sorted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>How many elements to generate. </td></tr>
    <tr><td class="paramname">low</td><td>The elements in array are at least this big. </td></tr>
    <tr><td class="paramname">high</td><td>The elements in array are at no larger than this. </td></tr>
    <tr><td class="paramname">cmp</td><td>A function to compare two array elements. </td></tr>
    <tr><td class="paramname">generator</td><td>The function to generate array elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <code>array</code> (the callers are responsible to deallocate it). </dd></dl>

</div>
</div>
<a class="anchor" id="a82f610f167ab4a8994de4e99e1179bdf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structarray.html">array</a>* make_random_unique_array </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="array_8h.html#aec14133636951af4cfefa8eba04b1a8b">element_generator</a>&#160;</td>
          <td class="paramname"><em>generator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate an array where all elements are between <code>from</code> and <code>from+size</code> of size size, however elements aren't ordered. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>How many elements to generate. </td></tr>
    <tr><td class="paramname">from</td><td>The value of the first element. </td></tr>
    <tr><td class="paramname">generator</td><td>A function to generate an element given a pointer to the generated value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <code>array</code> (the callers are responsible to deallocate it). </dd></dl>

</div>
</div>
<a class="anchor" id="a0000fe5d9ed6e57bda69eea34a07c205"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structarray.html">array</a>* make_sparse_sorted_array </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>deviation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="array_8h.html#aec14133636951af4cfefa8eba04b1a8b">element_generator</a>&#160;</td>
          <td class="paramname"><em>generator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate sparse sorted array with element values starting from <code>from</code> and increasing by at most <code>deviation</code>, where the increase is decided using uniform random distribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>How many elements to generate. </td></tr>
    <tr><td class="paramname">from</td><td>The value of the first element. </td></tr>
    <tr><td class="paramname">deviation</td><td>How much the elements could differ (must be positive). </td></tr>
    <tr><td class="paramname">generator</td><td>A function to generate an element given a pointer to the generated value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <code>array</code> (the callers are responsible to deallocate it). </dd></dl>

</div>
</div>
<a class="anchor" id="a53ef3c3f836225974ba037a65d5e148f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structarray.html">array</a>* make_vedge_array </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>half_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="array_8h.html#aec14133636951af4cfefa8eba04b1a8b">element_generator</a>&#160;</td>
          <td class="paramname"><em>generator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate an array where elements in in its first half decrease by one starting with half the size of the array, while the elements in its second half increase by one as well, but starting from the element of the size of the array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">half_size</td><td>The largest element in this array. </td></tr>
    <tr><td class="paramname">generator</td><td>A function to generate an element given a pointer to the generated value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <code>array</code> (the callers are responsible to deallocate it). </dd></dl>

</div>
</div>
<a class="anchor" id="a91e444ddb2e14381a45aab7d6c342ec6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structiterator__impl.html">iterator_impl</a> *&#160;</td>
          <td class="paramname"><em>impl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The interface to iterating the array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">impl</td><td>The iterator aced on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a44ca12fe5a67ef3dc7c44ab630a025d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool next_it </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structiterator__impl.html">iterator_impl</a> *&#160;</td>
          <td class="paramname"><em>impl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1ec40a632dae64dc79f10a402c1300fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structarray.html">array</a>* shuffled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structarray.html">array</a> *&#160;</td>
          <td class="paramname"><em>sorted</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shuffles the <code>array</code> in-place and returns it. </p>

</div>
</div>
<a class="anchor" id="a3340550f4a0f549ef9ba8ce4b776294b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structarray.html">array</a>* slice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structarray.html">array</a> *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an array that shares data with <code>input</code>, but starts from <code>from</code> and up to <code>to</code>. </p>

</div>
</div>
<a class="anchor" id="a60d65c817587296555101f8b50591151"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structarray.html">array</a>* sorted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structarray.html">array</a> *&#160;</td>
          <td class="paramname"><em>unsorted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="array_8h.html#a1a6631e162730e046df6a09afc4e6f96">comparison_fn_t</a>&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts the <code>array</code> in-place using <code>cmp</code> function and returns it. </p>

</div>
</div>
<a class="anchor" id="af2ba95324821888148365ffc368f9ce6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void start_swap_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restets the swap operation counter. </p>

</div>
</div>
<a class="anchor" id="a8b8341fd64c0b0bb6b07f71751177e4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structarray.html">array</a> *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad2d8124f3b1adb8c181629681ab10950"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* to_string_array </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structarray.html">array</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a string representing the given <code>array</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <code>array</code> to print. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
