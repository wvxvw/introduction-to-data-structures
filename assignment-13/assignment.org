# -*- fill-column: 80; org-confirm-babel-evaluate: nil -*-

#+TITLE:     Assignment 13, Data-Structures
#+AUTHOR:    Oleg Sivokon
#+EMAIL:     olegsivokon@gmail.com
#+DATE:      <2016-04-09 Sat>
#+DESCRIPTION: Third assignment in the course Data-Structures
#+KEYWORDS: Data-Structures, Algorithms, Assignment
#+LANGUAGE: en
#+LaTeX_CLASS: article
#+LATEX_HEADER: \usepackage{commath}
#+LATEX_HEADER: \usepackage{pgf}
#+LATEX_HEADER: \usepackage{tikz}
#+LATEX_HEADER: \usetikzlibrary{shapes,backgrounds}
#+LATEX_HEADER: \usepackage{marginnote}
#+LATEX_HEADER: \usepackage{listings}
#+LATEX_HEADER: \usepackage{enumerate}
#+LATEX_HEADER: \usepackage{algpseudocode}
#+LATEX_HEADER: \usepackage{algorithm}
#+LATEX_HEADER: \usepackage{mathtools}
#+LATEX_HEADER: \setlength{\parskip}{16pt plus 2pt minus 2pt}
#+LATEX_HEADER: \renewcommand{\arraystretch}{1.6}

#+BEGIN_SRC emacs-lisp :exports none
  (setq org-latex-pdf-process
        '("latexmk -pdflatex='pdflatex -shell-escape -interaction nonstopmode' -pdf -f %f")
        org-latex-listings t
        org-src-fontify-natively t
        org-babel-latex-htlatex "htlatex")

  (defmacro by-backend (&rest body)
    `(progn
       (cl-case org-export-current-backend ,@body)))

  ;; (defmacro by-backend (&rest body)
  ;;   `(cl-case (when (boundp 'backend)
  ;;               (org-export-backend-name backend))
  ;;      ,@body))
#+END_SRC

#+RESULTS:
: by-backend

#+BEGIN_LATEX
\definecolor{codebg}{rgb}{0.96,0.99,0.8}
\definecolor{codestr}{rgb}{0.46,0.09,0.2}
\lstset{%
  backgroundcolor=\color{codebg},
  basicstyle=\ttfamily\scriptsize,
  breakatwhitespace=false,
  breaklines=false,
  captionpos=b,
  framexleftmargin=10pt,
  xleftmargin=10pt,
  framerule=0pt,
  frame=tb,
  keepspaces=true,
  keywordstyle=\color{blue},
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  stringstyle=\color{codestr},
  tabsize=2
}
\lstnewenvironment{maxima}{%
  \lstset{%
    backgroundcolor=\color{codebg},
    escapeinside={(*@}{@*)},
    aboveskip=20pt,
    captionpos=b,
    label=,
    caption=,
    showstringspaces=false,
    frame=single,
    framerule=0pt,
    basicstyle=\ttfamily\scriptsize,
    columns=fixed}}{}
}
\makeatletter
\newcommand{\verbatimfont}[1]{\renewcommand{\verbatim@font}{\ttfamily#1}}
\makeatother
\verbatimfont{\small}%
\clearpage
#+END_LATEX

* Problems

** Problem 1
   Find tight bounds on the given recurrences.  Assume $T(n)$ is constant for $n
   = 1$.

   #+HEADER: :exports results
   #+HEADER: :results (by-backend (pdf "latex") (t "raw"))
   #+BEGIN_SRC latex
     \begin{align*}
       T(n) &= 8T\left(\frac{n}{2}\right) + n + n^3 \\
       T(n) &= kT\left(\frac{n}{2}\right) + (k - 2)n^3 \\
       &\textit{where}\; k \in \mathbb{Z}: k \geq 2 \\
       T(n) &= 2T\left(\frac{n}{4}\right) + \sqrt{n} \times \lg n \\
       T(n) &= T\left(n - 1\right) + n \lg n + n \\
       T(n) &= n^2 \sqrt{n} \times T\left(\sqrt{n}\right) + n^5 \lg^3 n + \lg^5 n
     \end{align*}
   #+END_SRC

** Problem 2
   Find upper and lower bounds on:

   #+HEADER: :exports results
   #+HEADER: :results (by-backend (pdf "latex") (t "raw"))
   #+BEGIN_SRC latex
     \begin{align*}
       T(n) &= 2T(\frac{n}{2}) + n^3 \\
       T(n) &= T(\frac{9n}{10}) + n \\
       T(n) &= 16T(\frac{n}{4}) + n^2 \\
       T(n) &= 7T(\frac{n}{3}) + n^2 \\
       T(n) &= 7T(\frac{n}{2}) + n^2 \\
       T(n) &= 2T(\frac{n}{4}) + \sqrt{n} \\
       T(n) &= T(n - 1) + n \\
       T(n) &= T(\sqrt{n}) + 1
     \end{align*}
   #+END_SRC

** Problem 3
   Suggest a data-structure with the following properties:
   1. Populate in $O(n)$ time.
   2. Insert in $O(n \lg n)$ time.
   3. Extract minimal element in $O(\lg n)$ time.
   4. Extract median element in $O(\lg n)$ time.
   5. Extract maximal element in $O(\lg n)$ time.

*** Answer 6
    There is a simple, but impractical way of doing this---have four heaps:
    - $A$ is a =min-heap= containing elements greater than median.
    - $B$ is a =max-heap= containing elments smaller than median.
    - $C$ is a =max-heap= tracking the heap $A$.
    - $D$ is a =min-heap= tracking the heap $B$.

    Creation and insertion are essentially the same as they are in the regular
    =max-heap= and =mean-heap=.  Median element is either the root of $A$ or the
    root of $B$, depending on which heap has more elements.  Maximum element is
    the root of $C$ and minimal element is the root of $D$, so their extraction
    is just the glorified =extract-max= and =extract-min= correspondingly.

    Tracking is achieved using the following mechanism: Each node in each heap
    has an additional field that has a position of the tracked node in the other
    heap in it.  Once the position of the node is modified, in addition to
    =heapify-min= or =heapify-max=, the procedure also updates the index in the
    tracking node (this takes only constant time).

    Whenever a node is deleted, it also needs to be deleted from the tracking
    heap.  In this case, the rightmost element in the heap is placed in the cell
    previously occupied by the node being deleted.  Then =heapify-min= or
    =heapify-max= is performed, depending on the kind of heap it was.

    Note that this solution is impractical since it requires saving a lot of
    additional information, but if we were to relax the requirement of $O(n)$
    allowing $O(n \lg n)$ for population, then we could use something like
    order-statistic tree.

** Problem 4
   1. Prove that a sequence $S$ of length $n$ has at most three elements that
      repeat more than $\lfoor\frac{n}{4}\rfloor$ times.
   2. Write an algorithm finding all elements which repeat more than
      $\lfoor\frac{n}{4}\rfloor$ times.  Running time $O(n)$.

*** Answer 4
    Assume for contradiction that there are four elements in $S$ that repeat
    $\lfoor\frac{n}{4}\rfloor$ times.  That is exist an element in the sequence
    that repeats $\lfoor\frac{n}{4} + 1\rfloor$ times.  Note that
    $3\lfoor\frac{n}{4}\rfloor + \lfoor\frac{n}{4} + 1\rfloor > n$ contrary to
    assumed.  Hence, by contracition, there are at most three such elements.

*** Answer 5
    Simple solution involves using hash-table: loop over the sequence, using
    elements as keys in the hash-table.  Increment the key whenever you
    encounter the element.  Finally, loop over the hash-table to collect all
    those for which the condition holds.

    This can be improved by using $\lfoor\frac{n}{4}\rfloor$ hash-tables, first
    for the elements which have been seen just once, second---for the elements
    seen twice and so on.  Thus, instead of icnrementing the counter, the
    elements would be promoted to the last hash-table.  This removes the
    requirement of the final loop, but doesn't change the running time
    significantly.

    A more complicated way to do this, without using hash-tables is to do the
    following:
    1. Partition in three parts using the same partition procedure used in
       =quick-sort= algorithm.  If a partition is smaller than
       $\lfoor\frac{n}{4}\rfloor$, throw it away and repeat.
    2. At this point, the following could happen:
       - You have three partitions each containing the same element---you are
         done.
       - Further partitioning is impossible: no such elements exist---you are
         done.
       - Some partitions only contain same elements (store the element, throw
         away the partition), others contain different element: throw them away
         (they aren't candidates).

** Problem 5
   1. Given a sequence of real numbers: $(a_0, a_1, a_2, \dots, a_n)$ define:
      #+HEADER: :exports results
      #+HEADER: :results (by-backend (pdf "latex") (t "raw"))
      #+BEGIN_SRC latex
        \begin{align*}
          m &= \min\{a_i\;|\; 0 \leq i \leq n\} \\
          M &= \max\{a_i\;|\; 0 \leq i \leq n\}
        \end{align*}
      #+END_SRC

      Show that there exist $a_i, a_j$ s.t.:
      #+HEADER: :exports results
      #+HEADER: :results (by-backend (pdf "latex") (t "raw"))
      #+BEGIN_SRC latex
        \begin{align*}
          \abs{a_i - a_j} &\leq \frac{M - m}{n}
        \end{align*}
      #+END_SRC

   2. Write the algorithm for finding the $a_i, a_j$ from the question above.

*** Answer 5
    Note that the sequence with the given $M$ and $m$ will have $M - m = k \geq
    n$ elements.  Suppose now we arrange the elements in increasing order.
    Suppose, for contradiction, that none of the elements of the sequence
    satisfies $\abs{a_i - a_j} \leq \frac{M - m}{n}$, then it also means that
    the difference between every two adjacent elements must be at least
    $\frac{M - m + \epsilon}{n}$ for some positive $\epsilon$.  since there are
    k pairs of adjoint elements, we get that:

    #+HEADER: :exports results
    #+HEADER: :results (by-backend (pdf "latex") (t "raw"))
    #+BEGIN_SRC latex
      \begin{align*}
        \sum_{i=1}^k\left(a_i - a_{i-1}\right) &= \sum_{i=1}^k\left(\frac{M - m + \epsilon}{n}\right) \\
        &= \frac{k}{n}\left(M - m\right) + k \epsilon \geq M - m
      \end{align*}
    #+END_SRC

    contrary to assumed.  Hence, by contradiction, there must be at least one
    pair $a_i, a_j$ s.t. $\abs{a_i - a_j} \leq \frac{M - m}{n}$.
    
*** Answer 6
    The general idea for the algorithm is to normalize all members of the given
    sequence by subtracting the minimum and mutliplying by the ratio of one less
    than the length of the sequence and the difference between the maximum and
    the minumum.  Once done, do the insertion sort: two elements which fall in
    the same cell will have a distance between them less than the one between
    the minimum and the maximum divided into one less than the number of elements.

    #+HEADER: :exports results
    #+HEADER: :results (by-backend (pdf "latex") (t "raw"))
    #+BEGIN_SRC latex
      \begin{algorithm}
        \caption{Find $x, y \in Elts$ s.t. $\abs{x - y} \leq \frac{\max(Elts) - \min(Elts)}{\abs{Elts} - 1}$}
        \begin{algorithmic}
          \Procedure {$\textit{min-pair}$}{$elements$}
          \State \Call {$max \leftarrow \texit{max}$}{$elements$}
          \State \Call {$min \leftarrow \texit{min}$}{$elements$}
          \State \Call {$size \leftarrow \texit{size}$}{$elements$}
          \State \Call {$copy \leftarrow \textit{make-vector}$}{$size, nil$}
          \For {$element \in elements$} \Do
          \State {$index \leftarrow \lfloor \frac{(elt - min) \times (size - 1)}{max - min} \rfloor$}
          \If {$copy_{index} = nil$} \Then
          \State {$copy_{index} = element$}
          \Else
          \Return {$element, copy_{index}$}
          \EndIf
          \EndFor
          \EndProcedure
        \end{algorithmic}
      \end{algorithm}
    #+END_SRC
